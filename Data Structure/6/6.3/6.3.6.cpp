/*
 * 树可以看成是一个连通且 无环 的 无向 图。
 * 给定往一棵 n 个节点 (节点值为 1～n) 的树中添加一条边后的图。
 * 添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。
 * 图的信息记录于长度为 n 的二维数组 edges ，edges[i] = [ai, bi] 表示图中在 ai 和 bi 之间存在一条边。
 * 请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。
 * 如果有多个答案，则返回数组 edges 中最后出现的边。
 */

#include <iostream>
#include <vector>

class Solution
{
public:
    std::vector<int> findRedundantConnection(std::vector<std::vector<int>> &edges)
    {
        std::vector<int> parent(edges.size() + 1);
        for (int i = 1; i < parent.size(); i++)
        {
            parent[i] = i;
        }
        for (auto &edge : edges)
        {
            int root1 = find(parent, edge[0]);
            int root2 = find(parent, edge[1]);
            if (root1 == root2)
            {
                return edge;
            }
            parent[root1] = root2;
        }
        return {};
    }
    int find(std::vector<int> &parent, int index)
    {
        if (parent[index] != index)
        {
            parent[index] = find(parent, parent[index]);
        }
        return parent[index];
    }
};

int main()
{
    int n;
    std::cin >> n;
    std::vector<std::vector<int>> edges(n);
    for (int i = 0; i < n; i++)
    {
        edges[i].resize(2);
        std::cin >> edges[i][0] >> edges[i][1];
    }
    auto ans = Solution().findRedundantConnection(edges);
    std::cout << ans[0] << " " << ans[1];
    return 0;
}